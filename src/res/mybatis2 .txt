一 mybatis入门
	1.1 mybatis是什么
		MyBatis是一个简化和实现了 Java 数据持久化层(persistence layer)的开源框架，它抽象了大量的JDBC冗余代码，并提供了一个简单易用的API和数据库交互。
		MyBatis的前身是iBATIS，iBATIS于2002年由ClintonBegin创建。MyBatis3是iBATIS的全新设计，支持注解和Mapper。
		MyBatis流行的主要原因在于它的简单性和易使用性。在Java应用程序中，数据持久化层涉及到的工作有：将从数据库查询到的数据生成所需要的Java对象；将Java对象中的数据通SQL持久化到数据库中。
		MyBatis通过抽象底层的JDBC代码，自动化SQL结果集产生Java对象、Java对象的数据持久化数据库中的过程使得对SQL的使用变得容易。

	1.2 Git 是一个免费开源的分布式版本控制系统，被用于高速有效地处理大大小小项目中所有文件,在软件开发中使用的其他版本控制软件类似与SVN、VSS、CVS等等.

	1.3 作为一个分布式的版本控制系统，在Git中并不存在主库这样的概念，每一份复制出的库都可以独立使用，任何两个库之间的不一致之处都可以进行合并。github以托管各种git库，并提供一个web界面，可以说是一款易于使用的git图形客户端。我们熟知的spring、struts、Hibernate等框架的源代码在github上面都可以找到其源代码

	1.4 iBATIS一词来源于internet和abatis的组合，是一个在2002年发起的开放源代码项目。于2010年6月16号被谷歌托管，改名为MyBatis。
		ibatis的官网 http://ibatis.apache.org/ 进去官网会看到下面提示:
		apache ibatis is retired at the apache software foundation (2010/06/16)
		the original project team has moved to mybatis hosted at google code. see http://www.mybatis.org/ for more.
		然而http://www.mybatis.org/这个地址一直处于打不开状态...
		但是我们最终是可以在github中找到mybatis的相关下载的:
		mybatis在github中的地址
		https://github.com/mybatis/mybatis-3
		最新版本的mybatis的下载地址
		https://github.com/mybatis/mybatis-3/releases
		doc文档
		http://www.mybatis.org/mybatis-3/
	
	1.5 当前有很多Java实现的持久化框架，而MyBatis流行起来有以下原因：
		1.5.1 它消除了大量的JDBC冗余代码
			Java通过JDBC的API来操作关系型数据库，但是JDBC是一个非常底层的API,我们需要书写大量的代码来完成对数据库的操作。例如一个插入操作(参考之前学习JDBC时候的代码实例)
			但是使用mybatis来完成相同的插入操作要简单方便灵活的多:
			第一步:在SQLMapper映射配置文件中配置SQL语句，假定为StudentMapper.xml
			<insert id="insertStudent" parameterType="Student"> 
				INSERT INTO STUDENTS(ID,NAME,EMAIL)  
				VALUES(#{id},#{name},#{email}) 
			</insert> 
			第二步:创建一个StudentMapper接口
			public interface StudentMapper{ 
				void insertStudent(Student student); 
			} 
			第三步:编写java代码完成插入操作:
			SqlSession session = getSqlSessionFactory().openSession(); 
			StudentMapper mapper = session.getMapper(StudentMapper.class); 
			mapper.insertStudent(student); 
			
			特别之处的是，MyBatis还提供了其他的一些特性来简化持久化逻辑的实现
			它支持复杂的SQL结果集数据映射到嵌套的对象结构
			它支持一对一和一对多的结果集和Java对象的映射
			它支持根据输入的数据构建动态的SQL语句
		1.5.2 它有低的学习曲线
			MyBatis能够流行的首要原因之一在于它学习和使用起来非常简单，它取决于你Java和 SQL方面的知识。如果开发人员很熟悉Java和SQL，他们会发现MyBatis入门非常简单。
		1.5.3 它能很好地与传统数据库协同工作
			有时我们可能需要用不正规形式与传统数据库协同工作，使用成熟的ORM框架(例如大家熟知的Hibernate)有可能、但是很难跟传统数据库很好地协同工作，因为他们尝试将Java对象静态地映射到数据库的表上.而MyBatis是将查询的结果与Java对象映射起来，这使得MyBatis可以很好地与传统数据库协同工作。你可以根据面相对象的模型创建Java域对象，执行传统数据库的查询，然后将结果映射到对应的Java对象上。
		1.5.4 它可以接受SQL语句
			成熟的ORM框架鼓励使用实体对象和在其底层自动产生SQL语句。由于这种的SQL生成方式，我们有可能不能够利用到数据库的一些特有的特性。Hibernate允许执行本地SQL，但是这样会打破持久层和数据库独立的原则。MyBatis框架接受SQL语句，而不是将其对开发人员隐藏起来。由于MyBatis不会产生任何的SQL语句，所以开发人员就要准备SQL语句，这样就可以充分利用数据库特有的特性并且可以准备自定义的查询。另外，MyBatis 对存储过程也提供了支持。
		1.5.5 它提供了与Spring框架的集成支持
			MyBatis提供了与流行的依赖注入框架Spring的开包即用的集成支持，这将进一步简化MyBatis的使用
		1.5.6 它提供了与第三方缓存类库的集成支持
			MyBatis有内建的SqlSession级别的缓存机制，用于缓存Select语句查询出来的结果。除此之外，MyBatis提供了与多种第三方缓存类库的集成支持，如EHCache，OSCache，Hazelcast等。
		1.5.7 它引入了更好的性能
			性能问题是关乎软件应用成功与否的关键因素之一。为了达到更好的性能，需要考虑很多事情，而对很多应用而言，数据持久化层是整个系统性能的关键。MyBatis支持数据库连接池，消除了为每一个请求创建一个数据库连接的开销,MyBatis提供了内建的缓存机制，在SqlSession级别提供了对SQL查询结果的缓存。即:如果你调用了相同的select查询，MyBatis 会将放在缓存的结果返回，而不会去再查询数据库。MyBatis框架并没有大量地使用代理机制，因此对于其他的过度地使用代理的ORM框架而言，MyBatis可以获得更好的性能.
	
	1.6 mybatis的jar包
		mybatis的核心包只有一个mybatis-3.x.0.jar,另外还有一些【可选】的依赖包(日志、代理等所需要的),在下载的压缩包中可以找到.
	
	1.7 mybatis框架中一般需要俩种文件:
		第一种:mybatis的配置文件: mybatis-config.xml,其中包括数据库连接信息，类型别名等等
			特点:
				名字一般是固定的
				位置是src下面
			示例:
			<?xml version="1.0" encoding="utf-8"?> 
			<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" 
			"http://mybatis.org/dtd/mybatis-3-config.dtd"> 
			<configuration> 
			  <typeAliases> 
				<typeAlias alias="Student" type="com.briup.pojo.Student" /> 
			  </typeAliases> 
			  <environments default="development"> 
				<environment id="development"> 
				  <transaction Manager type="JDBC" /> 
				   <dataSource type="POOLED">
					<!--
					<property name="driver" value="com.mysql.jdbc.Driver" /> 
					<property name="url" value="jdbc:mysql://localhost:3306/test" /> 
					-->
					<property name="driver" value="oracle.jdbc.driver.OracleDriver" /> 
					<property name="url" value="jdbc:oracle:thin:@127.0.0.1:1521:XE" /> 
					<property name="username" value="test" /> 
					<property name="password" value="test" /> 
				  </dataSource> 
				</environment> 
			  </environments> 
			  <mappers> 
				<mapper resource="com/briup/pojo/StudentMapper.xml" /> 
			  </mappers> 
			</configuration> 


		第二种:mybatis的映射文件:XxxxxMapper.xml,这个xml文件中包括Xxxx类所对应的数据库表的各种增删改查sql语句
			特点:
				名字一般为XxxxMapper.xml,Xxxx是对应类的名字
				位置不固定,一般放到一个专门的package里面
			实例:
			<?xml version="1.0" encoding="utf-8"?> 
			<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" 
			"http://mybatis.org/dtd/mybatis-3-mapper.dtd"> 
			<mapper namespace="com.briup.pojo.StudentMapper"> 
			  <resultMap type="Student" id="StudentResult"> 
				<id property="id" column="id" /> 
				<result property="name" column="name" /> 
				<result property="email" column="email" /> 
			  </resultMap> 
			  <select id="findAllStudents" resultMap="StudentResult"> 
					SELECT * FROM STUDENTS 
			  </select> 
			  <select id="findStudentById" parameterType="int" resultType="Student"> 
				 SELECT ID AS STUDID, NAME, EMAIL  
					 FROM STUDENTS WHERE ID=#{Id} 
			  </select> 
			  <insert id="insertStudent" parameterType="Student"> 
				 INSERT INTO STUDENTS(ID,NAME,EMAIL)  
					 VALUES(#{id },#{name},#{email}) 
			  </insert> 
			</mapper> 
	
	1.8 mybatis中的映射接口XxxxMapper.java(对XxxxMapper.xml中的sql语句进行映射)
		mybatis中除了必须的jar包、各种xml配置文件之外,一般还需要有调用sql语句执行的接口XxxxMapper.java
		示例:
		public interface StudentMapper{
			List<Student> findAllStudents(); 
			Student findStudentById(Integer id); 
			void insertStudent(Student student); 
		}
		注意:接口中的方法的名字和XML文件定义的SQL映射语句的名称要相同
		同时我们不需要去实现该接口,因为mybatis中提供了相应的方式在运行期间动态生成该接口的实现类对象(动态代理技术,spring框架中会想些讲解动态代理).

	1.9 mybatis中的SqlSession接口和sqlSessionFactory接口
		SqlSession接口的实现类对象是mybatis中最重要的一个对象,我们可以使用该对象动态获得XxxxMapper.java接口的实现类对象,然后就可以调用到XxxxMapper.java接口中方法所映射的sql语句(在xml文件中配置的sql语句)。
		sqlSessionFactory接口的实现类对象是一个工厂对象,专门负责来产生SqlSession对象的
		例如:
		InputStream inputStream = Resources.getResourceAsStream("mybatis-config.xml"); 
		SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
		SqlSession sqlSession = sqlSessionFactory.openSession();
		
		//第一种执行sql语句的方式  通过XxxxMapper接口的实现类对象来调用
		//动态获得XxxxMapper接口的实现类
		StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);
		studentMapper.insertStudent(new Student(1,"tom","123@.qq.com"));
		
		//第二种执行sql语句的方式  执行调用XxxxMapper.xml中写好的sql语句
		//也可以【不通过】Mapper接口执行映射的SQL
		//然而，使用 Mapper接口是最佳实践
		//sqlSession.selectOne("com.briup.pojo.StudentMapper.findStudentById",1);

	1.10 编写一个简单的mybatis进行插入数据的实例
		1.10.1 数据库建表  dob=Date of Birth
			CREATE TABLE STUDENTS ( 
				stud_id number PRIMARY KEY, 
				name varchar2(50) , 
				email varchar2(50) , 
				dob date 
			); 
		
		1.10.2 新建一个项目,创建好相应的package及class
			package com.briup.pojo;
			import java.util.Date;
			public class Student {
				private Integer studId; 
				private String name; 
				private String email; 
				private Date dob;
				get/set
			}

		1.10.3 项目中引入mybatis的核心包以及可选的依赖包
			必须的包  mybatis-3.3.0.jar    ojdbc14.jar
			可选的包  junit-4.7.jar             log4j-1.2.17.jar
		1.10.4 mybatis中的配置文件和映射文件分别引入到项目中
			src下面的mybatis-config.xml:
			<?xml version="1.0" encoding="UTF-8"?>
			<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" 
			"http://mybatis.org/dtd/mybatis-3-config.dtd">
			<configuration>
				<typeAliases>
					<typeAlias type="com.briup.pojo.Student" alias="Student" />
				</typeAliases>

				<environments default="development">
					<environment id="development">
						<transactionManager type="JDBC"></transactionManager>
						<dataSource type="POOLED">
							<property name="driver" value="oracle.jdbc.driver.OracleDriver" /> 
							<property name="url" value="jdbc:oracle:thin:@127.0.0.1:1521:XE" /> 
							<property name="username" value="test" />
							<property name="password" value="test" />
						</dataSource>
					</environment>
				</environments>
				
				<mappers>
					<mapper resource="com/briup/mappers/StudentMapper.xml"/>
				</mappers>
				
			</configuration>



			com.briup.mappers包下面的StudentMapper.xml:

			<?xml version="1.0" encoding="UTF-8"?>
			<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" 
			"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
			<!-- com.briup.mappers.StudentMapper是我们定义接口的全限定名字 这样就可以使用接口调用映射的SQL语句了 这个名字一定要和接口对应上-->
			<mapper namespace="com.briup.mappers.StudentMapper">

				<resultMap type="Student" id="StudentResult">
					<id property="studId" column="stud_id" />
					<result property="name" column="name" />
					<result property="email" column="email" />
					<result property="dob" column="dob" />
				</resultMap>

				<select id="findAllStudents" resultMap="StudentResult">
					SELECT * FROM STUDENTS
				</select>

				<!-- 列名和属性名字不一致可以给查询的列起一个别名 -->
				<select id="findStudentById" parameterType="int" resultType="Student">
					SELECT STUD_ID AS STUDID,NAME,EMAIL,DOB
					FROM STUDENTS
					WHERE
					STUD_ID=#{id}
				</select>
				<insert id="insertStudent" parameterType="Student"> 
					INSERT INTO
					STUDENTS(STUD_ID,NAME,EMAIL,DOB) 
					VALUES(#{studId},#{name},#{email},#{dob}) 
				</insert>
			</mapper>
		
		1.10.5 配置log4j.properties文件中的日志输出:
			位置src下面
			内容:
			log4j.rootLogger=DEBUG, stdout 
			log4j.appender.stdout=org.apache.log4j.ConsoleAppender 
			log4j.appender.stdout.layout=org.apache.log4j.PatternLayout 
			log4j.appender.stdout.layout.ConversionPattern=%d [%-5p] %c - %m%n
			#show sql
			log4j.logger.java.sql.ResultSet=INFO  
			log4j.logger.org.apache=INFO  
			log4j.logger.java.sql.Connection=DEBUG  
			log4j.logger.java.sql.Statement=DEBUG  
			log4j.logger.java.sql.PreparedStatement=DEBUG 

		1.10.6 com.briup.mappers包下面新建一个接口StudentMapper.java,用来对应xml文件中的sql语句(映射),从而方便我们调用
			package com.briup.mappers;
			import java.util.List;
			import com.briup.pojo.Student;

			//创建映射器Mapper接口StudentMapper
			//方法名和StudentMapper.xml中定义的SQL映射定义名相同
			//这个其实就是dao层接口(数据访问层,负责和数据库进行交互)
			public interface StudentMapper {
				List<Student> findAllStudents(); 
				Student findStudentById(Integer id); 
				void insertStudent(Student student);
			}

		1.10.7 创建一个测试类StudentMapperTest.java
			package test;
			import java.io.InputStream;
			import java.util.Date;

			import org.apache.ibatis.io.Resources;
			import org.apache.ibatis.session.SqlSession;
			import org.apache.ibatis.session.SqlSessionFactory;
			import org.apache.ibatis.session.SqlSessionFactoryBuilder;
			import org.junit.Test;

			import com.briup.mappers.StudentMapper;
			import com.briup.pojo.Student;

			public class StudentMapperTest {
				
				@Test
				public void test_insert(){
					
					try {
						InputStream inputStream = Resources.getResourceAsStream("mybatis-config.xml"); 
						SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
						SqlSession sqlSession = sqlSessionFactory.openSession();
						
						StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);
						Student s = new Student(1,"tom","123@briup.com",new Date());
						studentMapper.insertStudent(s);
						sqlSession.commit();
					} catch (Exception e) {
						e.printStackTrace();
					}
					
				}
			}

		1.10.8 运行成功后会在控制台中看到log4j日志输出的这个程序运行的相关信息

		1.10.9 对mybatis的一些基本封装
			每次读取配置文件,产生一个工厂对象SqlSessionFactory,然后再生成出SqlSession对象,这个过程虽然并不复杂,但是也都是一些重复的代码流程,所以我们可以对其进行一个简单的封装:
			package com.briup.utils;

			import java.io.IOException;
			import java.io.InputStream;

			import org.apache.ibatis.io.Resources;
			import org.apache.ibatis.session.SqlSession;
			import org.apache.ibatis.session.SqlSessionFactory;
			import org.apache.ibatis.session.SqlSessionFactoryBuilder;

			public class MyBatisSqlSessionFactory {
				private static SqlSessionFactory sqlSessionFactory;
				
				public static SqlSessionFactory getSqlSessionFactory(){
					if(sqlSessionFactory == null){
						InputStream inputStream = null;
						try {
							inputStream = Resources.getResourceAsStream("mybatis-config.xml"); 
							sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
						} catch (IOException e) {
							e.printStackTrace();
							throw new RuntimeException(e.getCause());
						}
					}
					return sqlSessionFactory;
				}
				
				public static SqlSession openSession() { 
					return openSession(false); 
				}
				public static SqlSession openSession(boolean autoCommit) { 
					return getSqlSessionFactory().openSession(autoCommit); 
				}
				
			}

			之后每次使用的时候只需要调用该类中的静态方法openSession即可
			上面的代码可简写为: //注意事务是自动提交还是手动提交
			MyBatisSqlSessionFactory.openSession().getMapper(StudentMapper.class).insertStudent(s);
			
			*******************************************************
			注意:xml文件中写的sql语句,最后面不要写分号,否则会报错误,ORA-00911: 无效字符
			*******************************************************

二 mybatis配置详解
	MyBatis最关键的组成部分是SqlSessionFactory，我们可以从中获取SqlSession， 并执行映射的SQL语句。SqlSessionFactory对象可以通过基于XML的配置信息或者JavaAPI创建。
	
	2.1 使用xml配置Mybatis
		构建SqlSessionFactory最常见的方式是基于XML配置。下面的 mybatis-config.xml展示了一个典型的MyBatis配置文件的样子:
		<?xml version="1.0" encoding="utf-8"?> 
		<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" 
		"http://mybatis.org/dtd/mybatis-3-config.dtd"> 
		<configuration> 
		  <properties resource="application.properties"> 
			<property name="username" value="db_user" /> 
			<property name="password" value="verysecurepwd" /> 
		  </properties> 
		  <settings> 
			<setting name="cacheEnabled" value="true" /> 
		  </settings> 
		  <typeAliases> 
			<typeAlias alias="Student" type="com.briup.pojo.Student" /> 
			<package name="com.briup.pojo" /> 
		  </typeAliases> 
		  <typeHandlers> 
			<typeHandler handler="com.mybatis3.typehandlers.PhoneTypeHandler" /> 
			<package name="com.briup.typehandlers" /> 
		  </typeHandlers> 
		  <environments default="development"> 
			<environment id="development"> 
			  <transactionManager type="JDBC" /> 
			  <dataSource type="POOLED"> 
				<property name="driver" value="${jdbc.driverClassName}" /> 
				<property name="url" value="${jdbc.url}" /> 
				<property name="username" value="${jdbc.username}" /> 
				<property name="password" value="${jdbc.password}" /> 
			  </dataSource> 
			</environment> 
			<environment id="production"> 
			  <transactionManager type="MANAGED" /> 
			  <dataSource type="JNDI"> 
				<property name="data_source" value="java:comp/jdbc/MyBatisDemoDS" /> 
			  </dataSource> 
			</environment> 
		  </environments> 
		  <mappers> 
			<mapper resource="com/briup/mappers/StudentMapper.xml" /> 
			<mapper url="file:///D:/mybatisdemo/mappers/StudentMapper.xml" /> 
			<mapper class="com.briup.mappers.StudentMapper" /> 
		  </mappers> 
		</configuration> 

		2.1.1 environments元素
		environments是配置mybatis当前工作的数据库环境的地方
		MyBatis可以支持配置多个dataSource环境，可以将应用部署到不同的环境上，如DEV(开发环境)，TEST（测试环境），QA（质量评估环境）,UAT(用户验收环境),PRODUCTION（生产环境），可以通过将默认environments值设置成想要的environment的id值。

		有时候，我们可能需要在相同的应用下使用多个数据库,比如我们可能有shoppingcart数据库来存储所有的订单明细；使用reports数据库存储订单明细的合计，用作报告。(也就是如果系统在运行期间如果有【切换数据库环境】的需求,mybatis中也可以很轻松的实现).
		如果你的应用需要连接多个数据库，你需要将每个数据库配置成独立的环境，并且为每一个数据库创建一个SqlSessionFactory
		例如:
		<environments default="shoppingcart"> 
		  <environment id="shoppingcart"> 
			<transactionManager type="MANAGED" /> 
			<dataSource type="JNDI"> 
			  <property name="data_source" value="java:comp/jdbc/ShoppingcartDS" /> 
			</dataSource> 
		  </environment> 
		  <environment id="reports"> 
			<transaction Managertype="MANAGED" /> 
			<dataSource type="JNDI"> 
			  <property name="data_source" value="java:comp/jdbc/ReportsDS" /> 
			</dataSource> 
		  </environment> 
		</environments> 

		我们可以为以上每个环境创建一个SqlSessionFactory
		java代码: 
		inputStream = Resources.getResourceAsStream("mybatis-config.xml"); 
		//默认的环境 default
		SqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);

		//统计明细的环境 cart
		SqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream, "shoppingcart"); 

		//统计报表的环境 report
		SqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream, "reports");
		
		注意:一个数据库环境对应一个SqlSessionFactory对象
		注意:对于environments,我们可以在其中配置多个environment子元素,同时还需要在environment中配置dataSource和transactionManager元素。
 
		
		2.1.2 dataSource元素
		dataSource表示的是数据源:至少会包括该连接数据库的四种信息
		<dataSource type="POOLED"> 
		  <property name="driver" value="${jdbc.driverClassName}" /> 
		  <property name="url" value="${jdbc.url}" /> 
		  <property name="username" value="${jdbc.username}" /> 
		  <property name="password" value="${jdbc.password}" /> 
		</dataSource> 

		dataSource的类型type属性可以配置成其内置类型之一，如UNPOOLED，POOLED，JNDI。
		如果将类型设置成UNPOOLED，MyBatis会为每一个数据库操作创建一个新的连接，使用完了并关闭它，该方式适用于只有小规模数量并发用户的简单应用程序上。
	 
		如果将属性设置成POOLED，MyBatis会创建一个数据库连接池，连接池中的一个连接将会被用作数据库操作。一旦数据库操作完成，MyBatis会将此连接返回给连接池。在开发或测试环境中，经常使用此种方式。
	  
		如果将类型设置成JNDI(Java Naming and Directory Interface , Java命名和目录接口, 是SUN公司提供的一种标准的Java命名系统接口)，MyBatis从在应用服务器向配置好的JNDI数据源dataSource获取数据库连接。在生产环境中，优先考虑这种方式。
	 
		
		2.1.3 transactionManager元素 :事务管理器 
		MyBatis支持两种类型的事务管理器：JDBC 和 MANAGED. 
		JDBC事务管理器的使用，是在【jdbc程序】负责管理数据库连接的生命周期（提交、回退等等）的时候。如果将TransactionManager 属性设置成JDBC，MyBatis内部将使用JdbcTransactionFactory类创建TransactionManager。例如，部署到ApacheTomcat的应用程序，需要应用程序自己管理事务。

		MANAGED 事务管理器的使用，是在【应用服务器】负责管理数据库连接生命周期的时候。如果将TransactionManager属性设置成MANAGED时，MyBatis内部使用ManagedTransactionFactory 类创建事务管理器TransactionManager。例如，当一个Java EE的应用程序部署在类似JBoss，WebLogic，GlassFish等应用服务器上时，它们会使用EJB进行应用服务器的事务管理能力。在这些管理环境中，你可以使用MANAGED事务管理器。
		注：Managed 是托管的意思，即我们编写的应用程序本身不去管理事务，而是把事务管理交给应用所在的服务器进行管理。
 
		2.1.4 properties元素
		属性配置元素properties可以将配置值写死到mybatis-config.xml中,也可以具体到一个属性文件中,并且使用属性文件的key名作为占位符.
		在上述的配置中，我们将数据库连接属性配置到了application.properties文件中，并且为driver，URL等属性使用了占位符.

		在applications.properties文件中配置数据库连接参数，如下所示：
		jdbc.driverClassName=oracle.jdbc.driver.OracleDriver 
		jdbc.url=jdbc:oracle:thin:@127.0.0.1:1521:XE
		jdbc.username=test 
		jdbc.password=test
		
		在mybatis-config.xml文件中，为属性使用application.properties文件中定义的占位符：
		<!-- 读取application.properties文件中的数据key-value的形式 -->
		<properties resource="application.properties">
		  <!-- 注意:是applications.properties文件中的值优先级高 -->
		  <property name="jdbc.username" value="briup" /> 
		  <property name="jdbc.password" value="briup" /> 
		</properties> 
		<environments default="development"> 
			<environment id="development"> 
			  <transactionManager type="JDBC" /> 
			  <dataSource type="POOLED"> 
				<property name="driver" value="${jdbc.driverClassName}" /> 
				<property name="url" value="${jdbc.url}" /> 
				<property name="username" value="${jdbc.username}" /> 
				<property name="password" value="${jdbc.password}" /> 
			  </dataSource> 
			</environment> 
		</environments>  


		2.1.5 typeAliases元素: 类型别名 
		在SQLMapper配置文件中，对于resultType和parameterType属性值，我们需要使用JavaBean 的完全限定名。
		例如:
		<select id="findStudentById" parameterType="int"  
			resultType="com.briup.pojo.Student"> 
				SELECT STUD_ID AS ID, NAME, EMAIL, DOB  
				FROM STUDENTS WHERE STUD_ID=#{Id} 
		</select> 
		<update id="updateStudent" parameterType="com.briup.pojo.Student"> 
			UPDATE STUDENTS  
				SET NAME=#{name}, EMAIL=#{email}, DOB=#{dob}  
				WHERE STUD_ID=#{id} 
		</update> 

		注:parameterType表示将来调用这个sql语句的时候所传的参数的类型(参数值或者参数对象里面的属性值 用来替换sql语句中的占位符)
		resultType表示将来调用这个sql语句的时候所返回的结果的类型(方便mybatis给我们自动封装结果集)
		
		这里我们为resultType和parameterType属性值设置为Student类型的完全限定名：com.briup.com.Student
		
		我们可以为完全限定名取一个别名（alias），然后就可以在需要使用完全限定名的地方使用别名，而不是到处使用完全限定名。如下例子所示，为完全限定名起一个别名：
		<type Aliases> 
		  <type Alias alias="Student" type="com.briup.pojo.Student" /> 
		  <type Alias alias="Teacher" type="com.briup.pojo.Teacher" /> 
		</type Aliases> 

		然后在SQLMapper映射文件中, 如下使用Student的别名：
		<select id="findStudentById" parameterType="int" resultType="Student"> 
			SELECT STUD_ID AS ID, NAME, EMAIL, DOB  
			FROM STUDENTS WHERE STUD_ID=#{id} 
		</select> 
		<update id="updateStudent" parameterType="Student"> 
			UPDATE STUDENTS  
				SET NAME=#{name}, EMAIL=#{email}, DOB=#{dob}  
			WHERE STUD_ID=#{id} 
		</update> 
		
		你可以不用为每一个JavaBean单独定义别名,你可以为配置出需要取别名的类的所在的包(package)，MyBatis会自动扫描包内定义的类，然后分别为每个类注册一个小写字母开头的简单类名形式的别名。如下所示：
		<type Aliases> 
		  <package name="com.briup.pojo" /> 
		</type Aliases> 
		如果Student.java和 Teacher.java 定义在com.briup.pojo包中，则 com.briup.pojo.Student的别名会被注册为student。而com.briup.pojo.Teacher别名将会被注册为teacher
	
		还有另外一种方式为JavaBeans起别名，使用注解 @Alias: 
		@Alias("stu") 
		public class Student{
			....
		} 
		@Alias注解将会覆盖配置文件中的<typeAliases>定义。
		注意: @Alias 要和<package name=""/>标签配合使用,Mybatis会自动查看指定包内的类别名注解,如果没有这个注解,那么默认的别名就是类的名字


		2.1.6 typeHandlers元素: 类型处理器 
		当MyBatis将一个Java对象作为输入参数执行INSERT语句操作时，它会创建一个PreparedStatement对象，并且使用setXXX()方法对?号占位符 设置相应的参数值 。这里，XXX可以是int，String，Date 等 Java对象属性类型的任意一个。示例如下：
		<insert id="insertStudent" parameterType="Student"> 
			INSERT INTO STUDENTS(STUD_ID,NAME,EMAIL,DOB)  
			VALUES(#{studId},#{name},#{email},#{dob}) 
		</insert> 

		为执行这个语句，MyBatis将采取以下一系列动作：
			创建一个有占位符的PreparedStatement接口，如下：
			PreparedStatement ps = connection.prepare Statement 
                    ("INSERT INTO STUDENTS(STUD_ID,NAME,EMAIL,DOB) VALUES(?,?,?,?)"); 
			检查Student对象的属性studId的类型，然后使用合适setXXX方法去设置参数值。这里studId是Integer类型，所以会使用setInt()方法：ps.setInt(1,student.getStudId()); 

			类似地，对于name和email属性都是String类型MyBatis使用setString()方法设置参数。
			至于dob属性, MyBatis会使用setDate()方法设置dob处占位符位置的值。
			MyBaits会将java.util.Date类型转换为java.sql.Timestamp并设值：
			ps.setTimestamp(4, new Timestamp((student.getDob()).getTime())); 

		但MyBatis是怎么知道对于Integer类型属性使用setInt()和String类型属性使用setString()方法呢？其实MyBatis是通过使用类型处理器typeHandlers来决定这么做的。
		
		MyBatis对于以下的类型使用内置的类型处理器：所有的基本数据类型、基本类型的包装类型、 byte[]、java.util.Date、java.sql.Date、java,sql.Time、java.sql.Timestamp、java枚举类型等。所以当MyBatis发现属性的类型属于上述类型，他会使用对应的类型处理器将值设置到PreparedStatement中，同样地，当SQL结果集封装成java类对象的时候，也有类似的过程。
 
		那如果有一个自定义的类型，怎么存储存储到数据库呢？示例如下：假设表STUDENTS 有一个 PHONE 字段，类型为 VARCHAR2(15)，而 Student类有一个自定义类型属性phone(PhoneNumber类)
		
		alter table students add phone varchar2(15);
		alter table students drop column phone;

		java代码:
		PhoneNumber 类定义类型的 phoneNumber 属性。
 
		public class PhoneNumber{ 
			private String countryCode; 
			private String stateCode; 
			private String number; 
			public PhoneNumber(){ 
			} 
			public PhoneNumber(String countryCode, String stateCode, String number) { 
				this.countryCode = countryCode; 
				this.stateCode = stateCode; 
				this.number = number; 
			} 
			public String getAsString() { 
				return countryCode + "-" + stateCode + "-" + number; 
			} 
			// Setters and getters 
		} 
		 
		public class Student{ 
			private Integer id; 
			private String name; 
			private String email; 
			private PhoneNumber phone; 
			// Setters and getters 
		} 

		
		xml配置:
		<insert id="insertStudent" parameter Type="Student"> 
			insert into students(name,email,phone) 
			values(#{name},#{email},#{phone}) 
		</insert> 
	
		这里，参数对象中的属性phone的值需要传递给#{phone}；而参数对象的属性phone是 PhoneNumber类型。但是，MyBatis 并不知道该怎样来处理这个类型的对象。

		为了让MyBatis明白怎样处理这个自定义的Java对象类型，如PhoneNumber，我们可以创建一个自定义的类型处理器,MyBatis提供了抽象类BaseTypeHandler<T> ，我们可以继承此类创建自定义类型处理器。
		代码如下所示:
			package com.briup.typehandlers;

			import java.sql.CallableStatement;
			import java.sql.PreparedStatement;
			import java.sql.ResultSet;
			import java.sql.SQLException;

			import org.apache.ibatis.type.BaseTypeHandler;
			import org.apache.ibatis.type.JdbcType;

			import com.briup.pojo.PhoneNumber;

			public class PhoneTypeHandler extends BaseTypeHandler<PhoneNumber>{

				//遇到PhoneNumber参数的时候应该如何在ps中设置值
				@Override
				public void setNonNullParameter(PreparedStatement ps, int i, PhoneNumber parameter, JdbcType jdbcType)
						throws SQLException {
					ps.setString(i, parameter.getAsString());
				}

				//查询中遇到PhoneNumber类型的应该如何封装(使用列名封装)
				@Override
				public PhoneNumber getNullableResult(ResultSet rs, String columnName) throws SQLException {
					return new PhoneNumber(rs.getString(columnName));
				}

				//查询中遇到PhoneNumber类型的应该如何封装(使用列的下标)
				@Override
				public PhoneNumber getNullableResult(ResultSet rs, int columnIndex) throws SQLException {
					return new PhoneNumber(rs.getString(columnIndex));
				}

				//CallableStatement使用中遇到了PhoneNumber类型的应该如何封装
				@Override
				public PhoneNumber getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {
					return new PhoneNumber(cs.getString(columnIndex));
				}

			}
		
		注意:使用ps.setString()和rs.getString()方法是 :因为在数据库的表中phone列是VARCHAR类型。
 
		最后一旦我们实现了自定义的类型处理器，我们需要在mybatis-config.xml中注册它：
		<?xml version="1.0" encoding="utf-8"?> 
		<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" 
		"http://mybatis.org/dtd/mybatis-3-config.dtd"> 
		<configuration> 
		  <properties resource="application.properties" /> 
		  <type Handlers> 
			<type Handler handler="com.briup.typehandlers.PhoneTypeHandler" /> 
		  </type Handlers> 
		</configuration> 
		注册PhoneTypeHandler后, MyBatis就能够将Phone类型的对象值存储到VARCHAR类型的列上。
 

		
		2.1.7 settings元素: 全局参数设置
		注意:大多数情况下，【这些参数使用它们的默认值即可】
		为满足应用特定的需求，MyBatis默认的全局参数设置可以被覆盖掉，如下所示：
		<settings>
		  <setting name="cacheEnabled" value="true" /> 
		  <setting name="lazyLoadingEnabled" value="true" /> 
		  <setting name="multipleResultSetsEnabled" value="true" /> 
		  <setting name="useColumnLabel" value="true" /> 
		  <setting name="useGeneratedKeys" value="false" /> 
		  <setting name="autoMappingBehavior" value="PARTIAL" /> 
		  <setting name="defaultExecutorType" value="SIMPLE" /> 
		  <setting name="defaultStatementTimeout" value="25000" /> 
		  <setting name="safeRowBoundsEnabled" value="false" /> 
		  <setting name="mapUnderscoreToCamelCase" value="false" /> 
		  <setting name="localCacheScope" value="SESSION" /> 
		  <setting name="jdbcTypeForNull" value="OTHER" /> 
		  <setting name="lazyLoadTriggerMethods" value="equals,clone,hash Code ,to String" /> 
		  <setting name="proxyFactory" value="JAVASSIST" /> 
		  <setting name="aggressiveLazyLoading" value="true" /> 
		  <setting name="logImpl" value="LOG4J " /> 
		  <setting name="logPrefix" value="LOG4J " /> 
		  <setting name="callSettersOnNulls" value="false " /> 
		</settings> 


		<settings>
		  <!-- 这个配置使全局的映射器启用或禁用缓存 -->
		  <setting name="cacheEnabled" value="true" />

		  <!-- 全局启用或禁用延迟加载。当禁用时，所有关联对象都会即时加载 -->
		  <setting name="lazyLoadingEnabled" value="true" />

		  <!-- 允许或不允许多种结果集从一个单独的语句中返回（需要适合的驱动） -->
		  <setting name="multipleResultSetsEnabled" value="true" /> 

		  <!-- 使用列标签代替列名。不同的驱动在这方便表现不同。参考驱动文档或充分测试两种方法来决定所使用的驱动 -->
		  <setting name="useColumnLabel" value="true" /> 

		  <!-- 允许JDBC支持生成的键。需要适合的驱动。 -->
		  <setting name="useGeneratedKeys" value="false" /> 

		  <!-- 指定MyBatis如何自动映射列到字段/属性。PARTIAL只会自动映射简单、没有嵌套的结果。FULL会自动映射任意复杂的结果（嵌套的或其他情况） -->
		  <setting name="autoMappingBehavior" value="PARTIAL" />
		  
		  <!-- 配置默认的执行器。SIMPLE执行器没有什么特别之处。REUSE执行器重用预处理语句。BATCH执行器重用语句和批量更新 -->
		  <setting name="defaultExecutorType" value="SIMPLE" /> 

		  !-- 设置超时时间，它决定驱动等待一个数据库响应的时间 -->
		  <setting name="defaultStatementTimeout" value="25000" /> 
		  
		  <!-- 允许在嵌套语句中使用分页（RowBounds）默认false -->
		  <setting name="safeRowBoundsEnabled" value="false" /> 

		  <!-- 是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射。默认false -->
		  <setting name="mapUnderscoreToCamelCase" value="false" /> 

		  <!-- MyBatis 利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速重复嵌套查询。 默认值为 SESSION，这种情况下会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地会话仅用在语句执行上，对相同 SqlSession 的不同调用将不会共享数据。 -->
		  <setting name="localCacheScope" value="SESSION" /> 

		  <!-- 当没有为参数提供特定的 JDBC 类型时，为空值指定 JDBC 类型。 某些驱动需要指定列的 JDBC 类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER。 -->
		  <setting name="jdbcTypeForNull" value="OTHER" />

		  <!-- 指定对象的哪个方法触发一次延迟加载。 -->
		  <setting name="lazyLoadTriggerMethods" value="equals,clone,hashCode ,toString" /> 

		  <!-- CGLIB | JAVASSIST 默认JAVASSIST(MyBatis 3.3 or above)  -->
		  <!-- 指定 Mybatis 创建具有延迟加载能力的对象所用到的代理工具。 -->
		  <setting name="proxyFactory" value="JAVASSIST" /> 
		  <!-- 当启用时，对任意延迟属性的调用会使带有延迟加载属性的对象完整加载；反之，每种属性将会按需加载。 -->
		  <setting name="aggressiveLazyLoading" value="true" /> 
			
		  <!-- 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 -->
		  <setting name="logImpl" value="LOG4J " /> 

		  <!-- 指定 MyBatis 增加到日志名称的前缀。值可以是任意字符串 -->
		  <setting name="logPrefix" value="LOG4J " /> 

		  <!-- 指定当结果集中值为 null 的时候是否调用映射对象的 setter（map 对象时为 put）方法，这对于有 Map.keySet() 依赖或 null 值初始化的时候是有用的。注意基本类型（int、boolean等）是不能设置成 null 的。 默认false-->
		  <setting name="callSettersOnNulls" value="false " /> 
		</settings> 



		2.1.8 mappers元素: SQL映射
		SQLMapper文件中包含的SQL映射语句将会被应用通过使用其标签中的id值来执行。我们需要在mybatis-config.xml文件中配置SQLMapper文件的位置。
		<mappers> 
		  <mapper resource="com/briup/mappers/StudentMapper.xml" /> 
		  <mapper url="file:///D:/mybatisdemo/app/mappers/StudentMapper.xml" /> 
		  <mapper class="com.briup.mappers.StudentMapper" /> 
		  <package name="com.briup.mappers" /> 
		</mappers> 

		以上每一个<mapper> 标签都可以从不同类型的资源中加载映射mapper：
		resource属性用来指定在classpath中的mapper文件。
		url属性用来通过完全文件系统路径或者web URL地址来指向mapper文件
		class属性用来指向一个mapper接口
		package属性用来指向可以找到Mapper接口的包名
 

	2.2 使用Java API配置MyBatis (属于了解的内容,因为有了灵活的配置配置方法,这个方式几乎不用)
		MyBatis的SqlSessionFactory接口除了使用基于XML的配置创建外也可以通过JavaAPI编程式地被创建。每在XML中配置的元素，都可以编程式的创建。
		因为mybatis框架读取了我们配置的mybatis-config.xml中配置信息之后,然后利用这些信息去执行代码创建出我们需要的SqlSessionFactory,再从而进一步得到sqlSession,最后再进行各种数据库操作。
		所以其实我们完全可以不去配置任何信息直接把信息写在代码中,然后在按着之前的顺序创建出我们需要的SqlSessionFactory,再从而进一步得到sqlSession,最后再进行各种数据库操作。只是这样做再大多数时候都会降低代码的灵活性,所以我们基本上接触的框架都是有相应的配置文件的.

		例如:使用Java API创建SqlSessionFactory对象,之前是读取配置文件之后再创建,现在是自己把信息写到代码中,然后再创建该对象
		public static SqlSessionFactory getSqlSessionFactory() { 
			SqlSessionFactory sqlSessionFactory = null; 
			try { 
				DataSource dataSource = DataSourceFactory.getDataSource(); 
				TransactionFactory transactionFactory = new JdbcTransactionFactory(); 
				Environment environment = new Environment("development", transactionFactory, dataSource); 
				Configuration configuration = new Configuration(environment); 
				configuration.getTypeAliasRegistry().registerAlias("student",Student.class); 
				configuration.getTypeHandlerRegistry().register(PhoneNumber.class, PhoneTypeHandler.class);
				configuration.addMapper(StudentMapper.class); 
				sqlSessionFactory = new SqlSessionFactoryBuilder(). 
				build(configuration); 
			} 
			catch (Exception e) { 
				throw new RuntimeException(e); 
			} 
			return sqlSessionFactory; 
		} 

		类似的,每个在XML中配置的元素，都可以编程式的创建.
		注:这里就不一一介绍了，因为绝大多数情况下我们还是不会把配置信息直接写到代码中的
 
三 使用XML配置SQL映射器(映射文件)
	关系型数据库和SQL是经受时间考验和验证的数据存储机制。和其他的ORM 框架如Hibernate不同，MyBatis鼓励开发者可以直接使用数据库，而不是将其对开发者隐藏，因为这样可以充分发挥数据库服务器所提供的SQL语句的巨大威力。
	与此同时，MyBaits消除了书写大量冗余代码的痛苦，它让使用SQL更容易。在代码里直接嵌套SQL语句是很差的编码实践，并且维护起来困难。MyBaits使用了映射文件或注解来配置SQL语句。
 
	3.1 映射器文件和映射器接口
		我们已经看见了一些在映射器配置文件中配置基本的映射语句，以及怎样使用SqlSession对象调用它们的例子。现在让我们看一下在com.briup.mappers包中的StudentMapper.xml  配置文件内，是如何配置id为”findStudentById”的SQL语句的，代码如下：
		<?xml version="1.0" encoding="utf-8"?> 
		<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" 
		"http://mybatis.org/dtd/mybatis-3-mapper.dtd"> 
		<mapper namespace="com.briup.mappers.StudentMapper"> 
		  <select id="findStudentById" parameterType="int" resultType="Student"> 
			select stud_id as studId, name, email, dob  
			from students where stud_id=#{studId} 
		  </select> 
		</mapper> 
		我们可以通过下列代码调用findStudentById映射的SQL语句: 
		public Student findStudentById(Integer studId) { 
			SqlSession sqlSession = MyBatisSqlSessionFactory.openSession(); 
			try{ 
				Student student = sqlSession.selectOne("com.briup.mappers.StudentMapper.findStudentById", studId); 
				return student; 
			} 
			finally { 
				sql Session.close(); 
			} 
		} 


		我们可以通过字符串（字符串形式为：映射器配置文件所在的包名的namespace + sql语句id值，如上，即包名com.briup.mappers.StudentMapper和语句id的值findStudentById组成）调用映射的SQL语句，但是这种方式容易出错。你需要检查映射器配置文件中的定义，以保证你的输入参数类型和结果返回类型是有效的。
		
		【重点部分:】
		MyBatis通过使用映射器Mapper接口提供了更好的调用映射语句的方法。一旦我们通过映射器配置文件配置了映射语句，我们可以创建一个完全对应的一个映射器接口，xml映射文件中的namespace属性值和映射接口的全限定名需要保持一致。映射器接口中的方法签名也跟映射器配置文件中完全对应：方法名和配置文件中id值一致；方法参数类型和parameterType属性值一致；方法返回值类型和returnType属性值一致。
 
		上述的StudentMapper.xml文件,我们可以创建一个映射器接口StudentMapper.java如下：
		 
		package com.briup.mappers; 
		public interface StudentMapper{ 
			Student findStudentById(Integer id); 
		} 
		在Student Mapper.xml映射器配置文件中，其名空间namespace应该跟StudentMapper接口的全限定名保持一致。另外，StudentMapper.xml中语句id, parameterType，returnType 应该分别和StudentMapper接口中的方法名，参数类型，返回值相对应。
 
		使用映射器接口我们可以以类型安全的形式调用调用映射语句。如下所示：
		 
		public Student findStudentById(Integer studId){ 
			SqlSession sqlSession = MyBatisSqlSessionFactory.openSession();  
			try { 
				StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class); 

				return studentMapper.findStudentById(studId); 
			} 
			finally { 
				sqlSession.close(); 
			} 
		} 


	3.2 映射语句
	MyBatis提供了多种元素来配置不同类型的语句，如SELECT，INSERT，UPDATE，DELETE。让我们看看如何具体配置映射语句
		
		3.2.1 INSERT 插入语句
		一个INSERT语句可以在<insert>标签元素在映射器XML配置文件中配置，如下所示：
		<insert id="insertStudent" parameterType="Student"> 
			INSERT INTO STUDENTS(STUD_ID,NAME,EMAIL, PHONE) VALUES(#{studId},#{name},#{email},#{phone}) 
		</insert> 
		这里我们设置一个ID属性为insertStudent，可以在名空间 com.briup.mappers.StudentMapper.insertStudent中唯一标识该sql语句。parameterType 属性是一个完全限定类名或者是一个类型别名（alias）。
		
		我们可以如下调用这个语句：
		int count =  sqlSession.insert("com.briup.mappers.StudentMapper.insertStudent", student); 
		sqlSession.insert() 方法返回执行 INSERT 语句后所影响的行数。
		
		如果不使用名空间（namespace）和语句 id 来调用映射语句，你可以通过创建一个映射器Mapper 接口，并以类型安全的方式调用方法，如下所示：
		package com.briup.mappers; 
		public interface Student Mapper{ 
			int insertStudent(Student student); 
		} 
		你可以如下调用insertStudent映射语句：
		StudentMapper mapper = sqlSession.getMapper(StudentMapper.class); 
		int count = mapper.insertStudent(student); 
 
		自动生成主键:
		在上述的INSERT语句中，我们为可以自动生成（auto-generated）主键的列 STUD_ID 插入值。我们可以使用useGeneratedKeys和keyProperty属性让数据库生成auto_increment列的值，并将生成的值设置到其中一个输入对象属性内，如下所示：
		 
		<insert id="insertStudent" parameterType="Student" useGeneratedKeys="true" keyProperty="studId"> 
			INSERT INTO STUDENTS(NAME, EMAIL, PHONE) VALUES(#{name},#{email},#{phone}) 
		</insert> 
		这里STUD_ID列值将会被数据库自动生成(如mysql)，并且生成的值会被设置到student对象的studId属性上。
 
		但是有些数据库如Oracle并不支持AUTO_INCREMENT列，其使用序列（SEQUENCE）来生成主键值。假设我们有一个名为my_seq的序列来生成SUTD_ID主键值。使用如下代码来生成主键：
		drop sequence my_seq;
		create sequence my_seq;

		<insert id="insertStudent" parameterType="Student"> 
			<selectKey keyProperty="studId" resultType="int" order="BEFORE"> 
				SELECT my_seq.nextval FROM DUAL 
			</selectKey> 
			INSERT INTO STUDENTS(STUD_ID,NAME,EMAIL, PHONE) 
				VALUES(#{studId},#{name},#{email},#{phone}) 
		</insert> 
		这里我们使用了<selectKey>子元素来生成主键值，并将值保存到Student对象的studId 属性上。属性order=“before”表示MyBatis将取得序列的下一个值作为主键值，并且在执行INSERT语句之前将值设置到studId属性上。
 
		注:SelectKey需要注意order属性，像MySQL、SQLServer等一类支持自动增长类型的数据库中，order需要设置为after才会取到正确的值。
		像Oracle这样取序列的情况，需要设置为before，否则会报错。

	
		3.2.2 UPDATE 更新语句
		一个UPDATE SQL语句可以在<update>元素在映射器XML配置文件中配置，如下所示：
		<update id="updateStudent" parameterType="Student"> 
			UPDATE STUDENTS SET NAME=#{name}, EMAIL=#{email}, PHONE=#{phone} 
			WHERE STUD_ID=#{studId} 
		</update> 

		我们可以如下调用此语句：
		int noOfRowsUpdated = sqlSession.update("com.briup.mappers.StudentMapper.updateStudent", student); 
		sqlSession.update()方法返回执行UPDATE语句之后影响的行数。
	
		如果不使用名空间（namespace）和语句id来调用映射语句，你可以通过创建一个映射器Mapper接口，并以类型安全的方式调用方法，如下所示：
		 
		package com.briup.mappers; 
		public interface StudentMapper{ 
			int updateStudent(Student student); 
		} 

		你可以使用映射器Mapper接口来调用updateStudent语句，如下所示：
		StudentMapper mapper = sqlSession.getMapper(StudentMapper.class); 
		int noOfRowsUpdated = mapper.updateStudent(student); 

		
		3.2.3 DELETE 删除语句
		一个DELETE SQL语句可以在<update>元素在映射器XML配置文件中配置，如下所示
		<delete id="deleteStudent" parameterType="int"> 
		   DELETE FROM STUDENTS WHERE STUD_ID=#{id} 
		</delete> 

		我们可以如下调用此语句：
		int studId = 1; 
		int noOfRowsDeleted = sqlSession.delete("com.briup.mappers.StudentMapper.deleteStudent", studId); 
		sqlSession.delete()方法返回 delete 语句执行后影响的行数。
 
		如果不使用名空间（namespace）和语句 id 来调用映射语句，你可以通过创建一个映射器 Mapper 接口，并以类型安全的方式调用方法，如下所示：
		package com.briup.mappers; 
		public interface StudentMapper{ 
		  int deleteStudent(int studId); 
		} 
		你可以使用映射器Mapper接口来调用updateStudent语句，如下所示：
		StudentMapper mapper = sqlSession.getMapper(StudentMapper.class); 
		int noOfRowsDeleted = mapper.deleteStudent(studId);

		3.2.4 SELECT 查询语句
		MyBatis真正强大的功能，在于映射SELECT查询结果到java的各种类型。
		让我们看看一个简单的select查询是如何（在MyBatis中）配置的，如下所示：
		<select id="findStudentById" parameterType="int"  
		resultType="Student"> 
			SELECT STUD_ID, NAME, EMAIL, PHONE  
				FROM STUDENTS  
			WHERE STUD_ID=#{stud Id} 
		</select> 
		我们可以如下调用此语句：
		int studId = 1; 
		Student student = sqlSession.selectOne("com.briup.mappers.StudentMapper.findStudentById", studId);

		如果不使用名空间（namespace）和语句 id 来调用映射语句，你可以通过创建一个映射器 Mapper 接口，并以类型安全的方式调用方法，如下所示：
		package com.briup.mappers; 
		public interface StudentMapper{ 
			Student findStudentById(Integer studId); 
		}
		你可以使用映射器Mapper接口来调用 findStudentById 语句，如下所示：
		StudentMapper mapper = sqlSession.getMapper(StudentMapper.class); 
		Student student = mapper.findStudentById(studId); 

		如果你检查Student对象的属性值，你会发现studId属性值并没有被stud_id列值填充。这是因为MyBatis自动对java对象中和列名匹配的属性进行填充。这就是为什么name,email和 phone属性被填充而studId属性没有被填充。
		解决这一问题，我们可以为列名起一个可以与JavaBean中属性名匹配的别名，如下所示：
		<select id="findStudentById" parameterType="int"  
		resultType="Student"> 
			SELECT STUD_ID AS studId, NAME,EMAIL, PHONE  
				FROM STUDENTS  
			WHERE STUD_ID=#{studId} 
		</select> 

		
		MyBatis执行返回多条结果的SELECT语句查询，如下所示：
		<select id="findAllStudents" resultType="Student"> 
			SELECT STUD_ID AS studId, NAME,EMAIL, PHONE  
			FROM STUDENTS 
		</select>

		List<Student> students =  
		sqlSession.selectList("com.briup.mappers.StudentMapper.findAllStudents"); 

		映射器 Mapper 接口 StudentMapper 可以如下定义：
		package com.briup.mappers; 
		public interface StudentMapper{ 
			List<Student> findAllStudents(); 
		} 
 
		使用上述代码，我们可以如下调用
		StudentMapper mapper = sqlSession.getMapper(StudentMapper.class); 
		List<Student> students = mapper.findAllStudents(); 

		如果你注意到上述的SELECT映射定义，你可以看到，我们为所有的映射语句中的stud_id 起了别名。我们可以使用ResultMaps，来避免上述的到处重复别名。我们稍后会继续讨论。
		除了java.util.List，你也可以使用其他类型的集合类，如Set,Map，以及（SortedSet）。MyBatis 根据集合的类型，会采用适当的集合实现，如下所示：
		对于List，Collection，Iterable类型，MyBatis将返回java.util.ArrayList 
		对于Map类型，MyBatis 将返回java.util.HashMap  
		对于Set类型，MyBatis 将返回java.util.HashSet 
		对于SortedSet类型，MyBatis将返回java.util.TreeSet 

	3.3 结果集映射 ResultMaps
		ResultMaps被用来将SELECT语句的结果集映射到java对象的属性中。我们可以定义结果集映射ResultMaps并且在一些SELECT语句上引用resultMap。MyBatis的结果集映射 ResultMaps特性非常强大，你可以使用它将简单的SELECT语句映射到复杂的一对一、一对多关系的SELECT语句上。


		3.3.1 简单ResultMap 
		一个映射了查询结果为Student类型的resultMap定义如下：
		<resultMap id="StudentResult" type="com.briup.pojo.Student"> 
		  <id property="studId" column="stud_id" /> 
		  <result property="name" column="name" /> 
		  <result property="email" column="email" /> 
		  <result property="phone" column="phone" /> 
		</resultMap>

		<select id="findAllStudents" resultMap="StudentResult"> 
			SELECT * FROM STUDENTS 
		</select> 
		<select id="findStudentById" parameterType="int" resultMap="StudentResult"> 
			SELECT * FROM STUDENTS WHERE STUD_ID=#{studId} 
		</select> 

		resultMap的id值应该在此名空间内是唯一的,并且type属性是完全限定类名或者是返回类型的别名。
		<result>子元素被用来将一个resultset列映射到对象的一个属性中。
		<id>元素和<result>元素功能相同，不过<id>它被用来映射到唯一标识属性，用来区分和比较对象（一般和主键列相对应）。
		在<select>语句中，我们使用了resultMap属性，而不是resultType属性。当<select>语句中配置了resutlMap属性，MyBatis会使用表中的列名与对象属性 【映射关系】 来填充对象中的属性值。
		
		注意:resultType和resultMap二者只能用其一，不能同时使用。


		<select>映射语句中如何将查询【一条】数据填充到HashMap中?
		<select id="findStudentById" parameterType="int" resultType="map"> 
			SELECT * FROM STUDENTS WHERE STUD_ID=#{studId} 
		</select> 
		在上述的<select>语句中，我们将resultType配置成map，即java.util.HashMap的别名。在这种情况下，结果集的列名将会作为Map中的key值，而列值将作为Map的value值。
 
		HashMap<String,Object> studentMap = sqlSession.selectOne("com.briup.mappers.StudentMapper.findStudentById", studId); 
		System.out.println("stud_id :"+studentMap.get("stud_id")); 
		System.out.println("name :"+studentMap.get("name")); 
		System.out.println("email :"+studentMap.get("email")); 
		System.out.println("phone :"+studentMap.get("phone"));



		<select>映射语句中如何将查询【多条】数据填充到HashMap中?
		<select id="findAllStudents" resultType="map"> 
			SELECT STUD_ID, NAME, EMAIL, PHONE FROM STUDENTS 
		</select> 

		由于resultType=”map”和语句返回多行，则最终返回的数据类型应该是List<Map<String,Object>>，如下所示：

		List<Map<String, Object>> studentMapList = sqlSession.selectList("com.briup.mappers.StudentMapper.findAllStudents"); 
		for(Map<String, Object> studentMap : studentMapList) { 
		System.out.println("studId :" + studentMap.get("stud_id")); 
			System.out.println("name :" + studentMap.get("name")); 
			System.out.println("email :" + studentMap.get("email")); 
			System.out.println("phone :" + studentMap.get("phone")); 
		} 


		其他实例1:
		<select id="findAllStudents_student" resultType="Student">
			SELECT STUD_ID AS STUDID,NAME,EMAIL,DOB
			FROM STUDENTS
		</select>
		对应的接口中的方法,你写什么类型的集合,Mybatis就给你返回什么类型的集合,但是要注意使用SortedSet的时候,Student类需要实现Comparable接口,否则是不能进行排序的
		例如:
		public List<Student> findAllStudents_List();
		或者
		public Set<Student> findAllStudents_Set();
		或者
		public SortedSet<Student> findAllStudents_SortedSet();


		其他实例2:
		<select id="findAllName_list" resultType="String">
			SELECT NAME
			FROM STUDENTS
		</select>
		对应的接口中的方法: 把查询到所有名字都放到List集合中并返回
		public List<String> findAllName_list();

		
		其他实例3:
		<select id="findCount_int" resultType="int">
			SELECT count(*)
			FROM STUDENTS
		</select>
		对应的接口中的方法: 把查询到的这个值直接返回
		public int findCount_int();


		3.3.2 拓展 ResultMap 
		(注:这个可以在下面的一对一映射中进行测试,因为这里需要建立一对一关系的表结构)
		我们可以从从另外一个<resultMap>，拓展出一个新的<resultMap>，这样，原先的属性映射可以继承过来，以实现:
		<resultMap type="Student" id="StudentResult"> 
		  <id property="stud Id" column="stud_id" /> 
		  <result property="name" column="name" /> 
		  <result property="email" column="email" /> 
		  <result property="phone" column="phone" /> 
		</resultMap>
		
		<!-- Student类中又新增加了一个属性,该属性的类型是Address -->
		<!-- 自定义类Address,类中也有多个属性,同时数据库中ADDRESSES表与其对应 -->
		<resultMap type="Student" id="StudentWithAddressResult" extends="StudentResult"> 
		  <result property="address.addrId" column="addr_id" /> 
		  <result property="address.street" column="street" /> 
		  <result property="address.city" column="city" /> 
		  <result property="address.state" column="state" /> 
		  <result property="address.zip" column="zip" /> 
		  <result property="address.country" column="country" /> 
		</resultMap> 

		其中id为StudentWithAddressResult的resultMap拓展了id为StudentResult的resultMap

		如果你只想映射Student数据，你可以使用id为StudentResult的resultMap,如下所示：
		 
		<select id="findStudentById" parameterType="int"  
		resultMap="StudentResult"> 
			SELECT * FROM STUDENTS WHERE STUD_ID=#{stud Id} 
		</select> 

		如果你想将映射Student数据和Address数据，你可以使用id为StudentWithAddressResult的 resultMap：
		<select id="selectStudentWithAddress" parameterType="int"  
		resultMap="StudentWithAddressResult"> 
			SELECT STUD_ID, NAME, EMAIL, PHONE, A.ADDR_ID, STREET, CITY, STATE, ZIP, COUNTRY 
			FROM STUDENTS S LEFT OUTER JOIN ADDRESSES A ON  
					S.ADDR_ID=A.ADDR_ID 
			WHERE STUD_ID=#{studId} 
		</select> 
		注:该sql语句使用了连接查询中的左外连接,也可以使用等值连接
	